/* Copyright 2022 Brian Marre
 *
 * This file is part of PMacc.
 *
 * PMacc is free software: you can redistribute it and/or modify
 * it under the terms of either the GNU General Public License or
 * the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PMacc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License and the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License
 * and the GNU Lesser General Public License along with PMacc.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <cstdint>

#include "picongpu/particles/atomicPhysics2/GetPhysicalEnergy.hpp"

// debug only
#include "picongpu/particles/atomicPhysics2/DebugHelper.hpp"

namespace picongpu
{
    namespace particles
    {
        namespace atomicPhysics2
        {
            /** binning kernel
             *
             * called by binElectrons sub-stage, resets the to the superCell corresponding
             * histogram and then bins all macro particles of the species T_ElectronSpecies
             * in the given superCell into the given histogram
             *
             * @tparam T_ElectronSpecies species of electron, must be actual type, not alias
             * @tparam T_Histogram type of histogram used per superCell
             * @tparam T_numWorkers number of workers per Block/superCell
             */
            template<typename T_ElectronSpecies, typename T_Histogram, uint32_t T_numWorkers>
            struct BinElectronsKernel
            {
                /** call operator
                 *
                 * @param acc accelerator object containing the device and block
                 *  information, passed by PMACC_KERNEL call
                 * @param areaMapper mapping of blockIndex to block superCell index
                 * @param electronBox deviceDataBox containing the particle frames of the
                 *  superCell
                 * @param localElectronHistogramDataBox deviceDataBox containing the
                 *  electron histograms of the local superCell
                 */
                template<
                    typename T_Acc,
                    typename T_AreaMapping,
                    typename T_ElectronBox,
                    typename T_localElectronHistogramDataBox>
                HDINLINE void operator() (
                    T_Acc const& acc,
                    T_AreaMapping areaMapping,
                    T_ElectronBox const electronBox,
                    T_localElectronHistogramDataBox localElectronHistogramDataBox
                    ) const
                {
                    // by definition our frameSize is always equal to the superCellSize
                    constexpr uint32_t frameSize = pmacc::math::CT::volume<SuperCellSize>::type::value;

                    // get index vector of superCell, kernel was called on
                    pmacc::DataSpace<simDim> const superCellIdx(
                        areaMapping.getSuperCellIndex(DataSpace<simDim>(cupla::blockIdx(acc))));

                    // get first T_ElectronSpecies particle frame
                    auto frame = electronBox.getLastFrame(superCellIdx);
                    auto particlesInSuperCell = electronBox.getSuperCell(superCellIdx).getSizeLastFrame();

                    // get histogram for current superCell
                    T_Histogram& histogram = localElectronHistogramDataBox(superCellIdx);

                    uint32_t const workerIdx = cupla::threadIdx(acc).x;

                    //reset histogram
                    auto forEachHistogramBin = lockstep::makeForEach<
                        histogram.getNumberResetOps(),
                        T_numWorkers
                        >( workerIdx );

                    forEachHistogramBin(
                        [&](lockstep::Idx const linearIdx)
                        {
                            histogram.reset(linearIdx);
                        });

                    cupla::__syncthreads(acc);

                    // bin electrons
                    auto forEachParticleSlotInFrame = lockstep::makeForEach<
                        frameSize,
                        T_numWorkers
                        >(workerIdx);

                    // serial in particlesFrames, parallel in particle slots of a frame
                    while(frame.isValid())
                    {
                        forEachParticleSlotInFrame(
                            [&](lockstep::Idx const linearIdx)
                            {
                                // executed kernel
                                if(linearIdx < particlesInSuperCell)
                                {
                                    auto particle = frame[linearIdx];

                                    float_X const energy = GetPhysicalEnergy::KineticEnergy(particle);
                                    // unit: eV

                                    histogram.binParticle(
                                        acc,
                                        energy, // unit: eV
                                        particle[weighting_]); // unitless
                                }
                            });
                        cupla::__syncthreads(acc);

                        frame = electronBox.getPreviousFrame(frame);
                        particlesInSuperCell = frameSize;
                    }

                    // debug only
                    debug::printHistogramToConsole(histogram);

                }
            };
        } // namespace atomicPhysics2
    } // namespace particles
} // namespace picongpu

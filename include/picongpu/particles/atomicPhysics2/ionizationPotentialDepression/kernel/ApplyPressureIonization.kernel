/* Copyright 2024 Brian Marre
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software you can redistribute it and or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/particles/atomicPhysics2/enums/ProcessClass.hpp"
#include "picongpu/particles/atomicPhysics2/initElectrons/InitIonizationElectron.hpp"
#include "picongpu/particles/creation/SpawnFromSourceSpecies.kernel"
#include "picongpu/particles/creation/SpawnFromSourceSpeciesModuleInterfaces.hpp"


namespace picongpu::particles::atomicPhysics2::ionizationPotentialDepression::kernel
{
    namespace s_enums = picongpu::particles::atomicPhysics2::enums;

    //! sanity checks for apply ApplyPressureIonizationKernel
    template<
        typename T_IonBox,
        typename T_IonizationElectronBox,
        // T_KernelConfigOptions:
        typename T_IPDModel,
        // T_SharedStateBoxes:
        typename T_LocalTimeRemainingBox,
        typename T_ChargeStateDataBox,
        typename T_AtomicStateDataBox,
        typename T_PressureIonizationStateDataBox,
        typename... T_IPDInputBoxes>
    struct ApplyPressureIonizationSanityCheckInputs
        : public SanityCheckInputs<
              T_IPDModel,
              T_LocalTimeRemainingBox,
              T_AtomicStateDataBox,
              T_ChargeStateDataBox,
              T_PressureIonizationStateDataBox,
              T_IPDInputBoxes...>
    {
        PMACC_CASSERT_MSG(
            AtomicStateDataBox_and_chargeStateDataBox_atomicNumber_not_consistent,
            T_AtomicStateDataBox::ConfigNumber::atomicNumber == T_ChargeStateDataBox::atomicNumber);
    };

    //! test for local time remaining <= 0 for superCell
    template<typename... T_KernelConfigOptions>
    struct SkipFinishedSuperCellsAtomicPhysics : public SkipSuperCellFunctor<T_KernelConfigOptions...>
    {
        template<typename T_LocalTimeRemainingBox, typename... T_addSharedDataBoxes>
        HDINLINE static bool test(
            pmacc::DataSpace<picongpu::simDim> const,
            pmacc::DataSpace<picongpu::simDim> const superCellFieldIndex,
            T_LocalTimeRemainingBox const localTimeRemainingBox,
            T_addSharedStateBoxes...)
        {
            return (localTimeRemainingBox[superCellFieldIndex] <= 0._X);
        }
    };

    template<typename T_Number, typename T_IPDModel>
    struct PressureIonizationPredictor : public PredictorFunctor<T_Number, T_IPDModel>
    {
        template<
            typename T_Ion,
            typename T_LocalTimeRemainingBox,
            typename T_AtomicStateDataBox,
            typename T_ChargeStateDataBox,
            typename T_PressureIonizationStateDataBox,
            typename... T_IPDInputBoxes>
        HDINLINE static T_Number getNumberNewParticles(
            T_Ion& ion,
            float_X const ionizationPotentialDepression,
            T_LocalTimeRemainingBox const,
            T_AtomicStateDataBox const atomicStateBox,
            T_ChargeStateDataBox const chargeStateBox,
            T_PressureIonizationStateDataBox const pressureIonizationStateBox,
            T_IPDInputBoxes const...)
        {
            auto const currentAtomicStateClctIdx = ion[atomicStateCollectionIndex_];
            auto const pressureIonizationStateClctIdx
                = pressureIonizationStateBox.pressureIonizationState(currentAtomicStateClctIdx);

            bool const noPressureIonizationPath = (pressureIonizationStateClctIdx == currentAtomicStateClctIdx);

            if(noPressureIonizationPath)
                return static_cast<T_Number>(0u);

            // do prediction
            auto const currentAtomicStateConfigNumber = atomicStateBox.configNumber(currentAtomicStateClctIdx);
            float_X const atomicStateEnergy = atomicStateBox.energy(currentStateClctIdx);

            // fully ionized state has no pressure ionization state --> currentChargeState < T_atomicNumber
            uint8_t const currentChargeState
                = T_AtomicStateDataBox::ConfigNumber::getChargeState(currentAtomicStateConfigNumber);
            uint8_t const chargeStatePressureIonizationState = T_AtomicStateDataBox::ConfigNumber::getChargeState(
                atomicStateBox.configNumber(pressureIonizationStateClctIdx));

            // eV
            float_X const ionizationEnergyGroundState = chargeStateBox.ionizationEnergy(currentChargeState);
            // eV
            float_X const ipdIonizationEnergy
                = ionizationEnergyGroundState - atomicStateEnergy - ionizationPotentialDepression;

            T_Number numberIonizationElectrons = static_cast<T_Number>(0u);

            if(ipdIonizationEnergy < 0._X)
            {
                // update ion atomic state
                ion[atomicStateCollectionIndex_] = pressureIonizationStateClctIdx;

                // get number of electrons to spawn
                numberIonizationElectrons = chargeStatePressureIonizationState - currentChargeState;
            }

            return numberIonizationElectrons;
        }
    };

    template<typename T_SharedStateType, typename T_IPDModel>
    struct CalculateIPDValue : public InitSharedStateFunctor<T_SharedStateType, T_IPDModel>
    {
        template<
            typename T_LocalTimeRemainingBox,
            typename T_ChargeStateDataBox,
            typename T_AtomicStateDataBox,
            typename T_PressureIonizationStateDataBox,
            typename... T_IPDInputBoxes>
        HDINLINE static T_SharedStateType init(
            pmacc::DataSpace<picongpu::simDim> const,
            pmacc::DataSpace<picongpu::simDim> const superCellFieldIndex,
            T_LocalTimeRemainingBox const,
            T_ChargeStateDataBox const,
            T_AtomicStateDataBox const,
            T_IPDInputBoxes const... ipdInputBoxes)
        {
            // eV
            return static_cast<T_SharedStateType>(
                T_IPDModel::calculateIPD<T_ChargeStateDataBox::atomicNumber>(superCellFieldIndex, ipdInputBoxes...));
        }
    };

    //! functor to get superCellFieldIdx
    template<typename... T_KernelConfigOptions>
    struct SuperCellFieldIndex : public SharedStateIndex<T_KernelConfigOptions...>
    {
        template<typename T_AreaMapping>
        HDINLINE static pmacc::DataSpace<SharedStateIndex::indexDim> get(
            T_AreaMapping const areaMapping,
            pmacc::DataSpace<picongpu::simDim> const superCellIdx)
        {
            // atomicPhysics superCellFields have no guard, but areMapping includes a guard
            //  -> must subtract guard to get correct superCellFieldIdx
            return superCellIdx - areaMapping.getGuardingSuperCells();
        }
    };

    using ApplyPressureIonizationModulConfig = particles::creation::ModuleConfig<
        ApplyPressureIonizationSanityCheck,
        SkipFinishedSuperCellsAtomicPhysics,
        PressureIonizationPredictor,
        atomicPhysics2::initElectrons::InitIonizationElectron<s_enums::ProcessClass::pressureIonization>,
        // ipd in eV
        float_X,
        CalculateIPDValue,
        SuperCellFieldIndex>;

    //! definition of ApplyPressureIonizationKernel
    template<typename T_IPDModel>
    using ApplyPressureIonizationKernel = particles::creation::SpawnFromSourceSpecies<
        // T_TypeNumber
        uint8_t,
        // T_passCascadeIndex
        false,
        // T_passSharedDataBoxes
        false,
        ApplyPressureIonizationModulConfig,
        T_IPDModel>;
} // namespace picongpu::particles::atomicPhysics2::ionizationPotentialDepression::kernel
